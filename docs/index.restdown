---
title: Moray: Joyent's Key-value Store.
markdown2extras: wiki-tables, code-friendly
apisections: Buckets, Objects
---

# Moray

This is the reference documentation for Moray, which is a key/value store built
on top of [Postgres](http://www.postgresql.org/) and
[ZooKeeper](http://zookeeper.apache.org/), which Moray to be high-availabile and
strongly consistent.

This documentation provides descriptions of the (HTTP) APIs that Moray offers,
as well as the semantics they provide.  Note that in the API sections, only
"extra" errors returned by that particular operation are listed.  You can always
get things like 400/405/... from the service.

# Overview

Moray allows you to store arbitrary data as a JSON document in a `bucket`. A
bucket is essentially a namespace, such that bucket `foo` can have a key `mykey`
and bucket `bar` can have a key `mykey` with different values.  There is no
limit on the number of buckets, nor on the number of keys in a bucket.  That
said, a single Moray instance is backed by a single logical Postgres instance,
so you are practically limited to how much data you can maintain.  The basic
operations on objects in a bucket are PUT, GET, DELETE.

Upon creating a bucket you are allowed to define the bucket to have indexes,
which allow you to later search for multiple records that match those indexes.
You need to choose wisely, as the "schema" for a bucket cannot be modified after
it has been created.  If indexes are defined on a bucket, when you write a
key/value pair, the value is automatically indexed server-side in Moray for you.
Indexes can be defined to be of type `number`, `boolean` or `string`.  They can
optionally be defined to enforce uniquness of a value.

Lastly, all records in a bucket are automatically "tombstoned" on update/delete,
which allows you to roll-back in the event you need to (note: not in the
transactional sense of "rollback").  You can query the tombstone only by the
key of a record.


# Buckets

## CreateBucket (POST /)

Creates a new bucket.  Name must be globally unique.  To allow "easy"
on-boarding, indexes default to type string, not unique, so you can easily
use curl.  If you need something outside that, you must create a bucket with a
JSON object.  The JSON "schema" is effectively:

    {
      "name": :name,
      "index": {
        :attribute: {
          "type": <string|number|boolean>,
          "unique": <true|false>
        }
      }
    }


Where `:name` is your value (and must match the regex `/[a-zA-Z0-9_\-\.~]+/`),
`:attribute` is the name of the key(s) you want to create indexes on from posted
values (an arbitrary number of these can be specified) and the constraints are
as above.

### Inputs

||**Field**||**Type**||**Description**||
||name||string||globally unique name for the bucket||
||index||object||The set of indexes and constraints to apply to future values||

### Returns

201 on success, and an object that adheres to the "schema" above.

### Errors

* BucketAlready
* MissingParameter
* InvalidArgument

## ListBuckets (GET /)

Returns a list of all known buckets in Moray.

### Inputs

* None

### Returns

200 on success, and an object where the keys are the bucket names, and the
values each bucket's schema:

    $ moray $MH/

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: e4de6e08-b125-4935-adcb-61f7bddedc44
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    Connection: close
    Content-Length: 49
    Content-MD5: 9n4EWK1WGJerOk1veyuL0A==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 20:02:08 GMT
    X-Response-Time: 16

    {
      "foo": {
        "name": {
          "type": "string",
          "unique": false
        }
      }
    }


### Errors

* None

## GetBucket [ListKeys] (GET /:bucket)

Returns a (potentially) paginated list of keys in the bucket. You can optionally
ask for the schema in this API call as well.

The return value will be an object where the keys are marked `keys`, and each
"subkey" contains `etag` and `mtime` (as ISO8601, not an RFC822 timestamp). On
the first call to this API, you can specify `limit` and `prefix`, which cap the
number of keys in a single response, and a prefix match to start looking at keys
from, respectively.  If the result set is "truncated", meaning there are
additional keys, there will be a "marker" in the `Link` header that you can pass
as an input value to the next call.  This marker will override prefix/limit
values, as it forces each "page" to be "homogonous" to first call.

Example:

    $ moray $MH/foo?limit=1

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 459ed9c0-2366-4c0c-99ac-0a94247102bd
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    x-total-keys: 2
    Link: </foo?marker=c6LrwWs3pdHkt35dXEOpktCJ%2F4i8oMvPyvbHadx6AlxPZuLMEyqAQikn6tQ5hppD,next>; rel="%s"
    Connection: close
    Content-Length: 95
    Content-MD5: Ppb/Jx7orcxzP1r0rIe4Sw==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 20:09:36 GMT
    X-Response-Time: 10

    {
      "keys": {
        "bar": {
          "etag": "92ed38d56614548c447c7ab1f306167b",
          "mtime": "2012-03-09T11:24:54.497Z"
        }
      }
    }


And continuing:

    $ moray $MH/foo?marker=c6LrwWs3pdHkt35dXEOpktCJ%2F4i8oMvPyvbHadx6AlxPZuLMEyqAQikn6tQ5hppD

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 435fe15f-9857-468b-9a49-d65e4d6fb7b4
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    x-total-keys: 2
    Connection: close
    Content-Length: 95
    Content-MD5: 6W2ZZAElhdbkmdpyLVB56g==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 20:10:35 GMT
    X-Response-Time: 8

    {
      "keys": {
        "baz": {
          "etag": "85c9f9fd33bb1d81b3660fb50d0fd545",
          "mtime": "2012-03-09T12:09:30.881Z"
        }
      }
    }

### Inputs

||**Field**||**Type**||**Description**||
||limit||number||maximum number of keys to return per page||
||marker||string||A continuation token that retrieves the next page||
||prefix||string||An optional key to start listing from||

### Returns

200 on success, and an object that looks like the above.

### Errors

* MissingParameter
* InvalidArgument
* ResourceNotFound

## SearchBucket (GET /search/:bucket)

Allows you to query a bucket for a set of records that match an index.  Note
this is not a streaming API (and it does not currently paginate), so be careful
about what you ask for here, or at least until pagination is added.

When searching for values, what you can pass in depends on what your schema was.
Currently this is basically in existence to serve up string query matches,
including glob matching (not full regex).  I.e., if the index was a string, you
can either search for exact match, or wildcard and put the `*` character
wherever you want.

Moray currently only supports one attribute/value lookup per request; put
another way, you cannot do AND/OR queries.

Integer and boolean types are (currently) exact match only.

    $ moray $MH/search/foo?name=*

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 080e7bd0-a443-4bc7-8f82-41413aea1c31
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    etag: 526a549bf03e75e58cb1bd0c6a47622a
    Connection: close
    Content-Length: 39
    Content-MD5: UmpUm/A+deWMsb0MakdiKg==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 20:14:43 GMT
    X-Response-Time: 6

    [
      {
        "name": "markc",
        "whoami": "developer"
      }
    ]


### Inputs

||**Field**||**Type**||**Description**||
||$attribute||$type||Value search you are interested in||

### Returns

200 on success, and an object that looks like the above.

### Errors

* MissingParameter
* InvalidArgument
* ResourceNotFound

## DeleteBucket (GET /:bucket)

Deletes a bucket *and all objects in the bucket*.  There is no recovery or
rollback from this operation.

    $ moray $MH/foo -X DELETE

    HTTP/1.1 204 No Content
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 342fda6e-88e0-4bbf-ac67-0b749ec2862d
    Access-Control-Allow-Methods: DELETE
    X-Api-Version: 1.0.0
    Connection: close
    Date: Fri, 09 Mar 2012 21:35:51 GMT
    X-Response-Time: 37


### Inputs

* None

### Returns

204 on success.

### Errors

* ResourceNotFound


# Objects

## PutObject (PUT /:bucket/:key)

Idempotently writes a document to a given key.  If the key did not previously
exist, it is created. If it did exist, the old value will be overwritten, and
the old value will be available in the tombstone (see below).  Any fields in the
JSON document will be automatically indexed.

Note this call works with HTTP conditional request headers; namely `If-Match`
and `If-None-Match`, which you can use to achieve test/set semantics.  You can
technically use the `Last-Modified` suite of headers as well, but that's not as
precise as an Etag, so you know, don't.

No content will be returned from this call.

    $ moray $MH/foo/bar -X PUT -d '{"name":"mark","email":"mark.cavage@joyent.com"}'

    HTTP/1.1 204 No Content
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: d0f419ca-dd24-4d1f-a253-b709e052df87
    Access-Control-Allow-Methods: PUT
    X-Api-Version: 1.0.0
    etag: 25f4ce69950ca7b19615c19cf1c459fd
    Connection: close
    Date: Fri, 09 Mar 2012 21:47:50 GMT
    X-Response-Time: 9

### Inputs

* None, besides your JSON document.

### Returns

204 on success.

### Errors

* PreconditionFailed
* ResourceNotFound

## GetObject (GET /:bucket/:key)

Retrieves a document from Moray.  You can use HTTP conditional headers here to
build an intelligent cache (i.e., 304 may be returned if using those headers).

Note that you can receive a 410 ResourceGone error if the object was deleted;
this is an indication that the key once existed, but was deleted.  You can
restore the object from the tombstone.

    $ moray $MH/foo/bar | json

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 8052d1e1-e624-44ee-850a-cc5c20a86944
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    etag: 25f4ce69950ca7b19615c19cf1c459fd
    Last-Modified: Fri, 09 Mar 2012 13:47:50 GMT
    Connection: close
    Content-Length: 48
    Content-MD5: JfTOaZUMp7GWFcGc8cRZ/Q==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 21:53:25 GMT
    X-Response-Time: 6

    {
      "name": "mark",
      "email": "mark.cavage@joyent.com"
    }

### Inputs

* None

### Returns

200 on success (with content), 304 on success if using `If-None-Match` and the
document was not modified.

### Errors

* PreconditionFailed
* ResourceNotFound
* ResourceGone

## DeleteObject (DELETE /:bucket/:key)

Deletes an object, and moves the key/value to the tombstone.  You can use
conditional request headers here, as with put/get.

    $ moray $MH/foo/bar -X DELETE

    HTTP/1.1 204 No Content
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: c99aa8d3-2ea4-4f97-8ded-e41af11f3135
    Access-Control-Allow-Methods: DELETE
    X-Api-Version: 1.0.0
    etag: 25f4ce69950ca7b19615c19cf1c459fd
    Last-Modified: Fri, 09 Mar 2012 13:47:50 GMT
    Connection: close
    Date: Fri, 09 Mar 2012 21:57:11 GMT
    X-Response-Time: 21

### Inputs

* None

### Returns

204 on success.

### Errors

* PreconditionFailed
* ResourceNotFound

## GetObjectTombstone (GET /:bucket/:key/tombstone)

Allows you to retrieve the previous value of a given object.  The value in the
tombstone could be becaues of an overwrite or a deletion.  Conditional requests
are supported.

    $ moray $MH/foo/bar/tombstone

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 3dbe4e5f-e12a-48b7-aca5-c96cbcfe04e0
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    etag: 25f4ce69950ca7b19615c19cf1c459fd
    Last-Modified: Fri, 09 Mar 2012 13:57:11 GMT
    Connection: close
    Content-Length: 48
    Content-MD5: JfTOaZUMp7GWFcGc8cRZ/Q==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 21:59:49 GMT
    X-Response-Time: 4

    {
      "name": "mark",
      "email": "mark.cavage@joyent.com"
    }

### Inputs

* None

### Returns

200 on success, or 304 if using `If-None-Match`

### Errors

* PreconditionFailed
* ResourceNotFound

## RestoreObject (POST /:bucket/:key/tombstone)

Allows you to restore an object to its tombstone value.  If the object is
currently "live", then the values are swapped. Example: if `/foo/bar` has value
`2`, and the tombstone has value `3`, performing a `RestoreObject` will mean
requests to `/foo/bar` will return `3` and the tombstone will now hold the value
`2`.  If the key does not have a live value, then the tombstone is simply moved
over, and there will no longer be a tombstone value at all.

    $ moray $MH/foo/bar/tombstone -X POST

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 148b4649-849a-4e2b-b8b9-47baa8f9e2f8
    Access-Control-Allow-Methods: POST
    X-Api-Version: 1.0.0
    etag: 25f4ce69950ca7b19615c19cf1c459fd
    Last-Modified: Fri, 09 Mar 2012 14:04:03 GMT
    Connection: close
    Content-Length: 48
    Content-MD5: JfTOaZUMp7GWFcGc8cRZ/Q==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 22:04:03 GMT
    X-Response-Time: 9

    {
      "name": "mark",
      "email": "mark.cavage@joyent.com"
    }

The value that will now be live is returned.

### Inputs

* None

### Returns

200 on success, and the new (old) live value.

### Errors

* PreconditionFailed
* ResourceNotFound


# Using cURL with Moray

Here's an easy alias to save on curl annoyances:

    $ alias moray='/usr/bin/curl -is -H "Accept-Version: >=1.0"" -H "Accept: application/json" -H "Content-Type: application/json"

To save 19 characters each time...

    $ export MH=http://localhost:8080

Then you could say run the following sequence:

Create a bucket `foo` with a (non-unique string) index on `name`.

    $ moray $MH/?bucket=foo\&index=name -X POST

    HTTP/1.1 201 Created
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: f766f756-ce29-438b-a25e-c780e7d6dd06
    Access-Control-Allow-Methods: POST
    X-Api-Version: 1.0.0
    Location: /foo
    Connection: close
    Content-Length: 41
    Content-MD5: Qye3VCQFxCqE86tIRhgUcQ==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 19:20:01 GMT
    X-Response-Time: 22

    {
      "name": {
        "type": "string",
        "unique": false
      }
    }

Add a document under `/foo/bar`:

    $ moray $MH/foo/bar -X PUT -d '{"name": "markc", "whoami": "developer"}'

    HTTP/1.1 204 No Content
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 2c6a0309-a801-4ae6-b54e-4ed49727c3ca
    Access-Control-Allow-Methods: PUT
    X-Api-Version: 1.0.0
    etag: 92ed38d56614548c447c7ab1f306167b
    Connection: close
    Date: Fri, 09 Mar 2012 19:23:00 GMT
    X-Response-Time: 16

Overwrite said document:

    $ moray $MH/foo/bar -X PUT -d '{"name":"Dr_Aweseome","whoami":"awesome"}'

    HTTP/1.1 204 No Content
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 2349b5c4-9581-4730-ab2e-96f20dd5cef8
    Access-Control-Allow-Methods: PUT
    X-Api-Version: 1.0.0
    etag: 67e5adbe7517e4880cdc929f66120239
    Last-Modified: Fri, 09 Mar 2012 11:23:00 GMT
    Connection: close
    Date: Fri, 09 Mar 2012 19:23:57 GMT
    X-Response-Time: 16

Find all records based on the `name` index that match `Dr*`:

    $ moray $MH/search/foo?name=Dr*

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 823ec46b-da8a-44b1-bb2e-bc1993af2d95
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    etag: bd0bb18184132213d4823742f33e2912
    Connection: close
    Content-Length: 43
    Content-MD5: vQuxgYQTIhPUgjdC8z4pEg==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 19:24:26 GMT
    X-Response-Time: 7

    [
      {
        "name": "Dr_Aweseome",
        "whoami": "awesome"
      }
    ]

Restore the previous `bar` document from the graveyard:

    $ moray $MH/foo/bar/tombstone -X POST

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: 0af90dfa-a05f-4599-8493-7bee5652831e
    Access-Control-Allow-Methods: POST
    X-Api-Version: 1.0.0
    etag: 92ed38d56614548c447c7ab1f306167b
    Last-Modified: Fri, 09 Mar 2012 11:24:54 GMT
    Connection: close
    Content-Length: 37
    Content-MD5: ku041WYUVIxEfHqx8wYWew==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 19:24:54 GMT
    X-Response-Time: 16

    {
      "name": "markc",
      "whoami": "developer"
    }

Ensure the new (old?) value is actually there, but let's do it conditionally
based on the `etag` of the 'dr awesome` value:

    $ moray -H 'If-None-Match: bd0bb18184132213d4823742f33e2912' $MH/foo/bar

    HTTP/1.1 200 OK
    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version
    Access-Control-Expose-Headers: X-Api-Version, X-Request-Id, X-Response-Time
    Server: Moray 1.0.0
    X-Request-Id: d2af173b-1fea-4750-9ae0-af5e380d65cb
    Access-Control-Allow-Methods: GET
    X-Api-Version: 1.0.0
    etag: 92ed38d56614548c447c7ab1f306167b
    Last-Modified: Fri, 09 Mar 2012 11:24:54 GMT
    Connection: close
    Content-Length: 37
    Content-MD5: ku041WYUVIxEfHqx8wYWew==
    Content-Type: application/json
    Date: Fri, 09 Mar 2012 19:32:22 GMT
    X-Response-Time: 4

    {
      "name": "markc",
      "whoami": "developer"
    }

# TODO

* Add pagination to search
* Add And/Or/Not (maybe) to search
* Add range queries on numbers to search
* Add "triggers"; that is, JS guaranteed to run after DB write but before commit.
* REST API test code
